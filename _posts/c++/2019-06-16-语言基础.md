---
layout: post
title: C++面试高频问题
category: 语言基础
keywords: C++,读书笔记
---
## 01 memcpy和memmove的区别
memcpy和memmove都c语言中的库函数，作用都是拷贝一定长度的内存的内容,唯一区别是：当内存空间发生局部重叠时，memmove能够保证拷贝结构是正确的，memcpy不能保证（两个重叠情况，一种能正确，另一种不能正确）
```c
void* memcpy(void* dst, const void* src, size_t count);
void* memmove(void* dst, const void* src, size_t count);
```
重叠情况一：
dst在src前面，均能正确复制

重叠情况二：
src在dst前面，memcpy不能正确复制

下面给出两个函数的实现：
```c
void* my_memcpy(void* dst, const void* src, size_t count){
    char* tmp = (char*)dst;//将void*强转为char*,void*不能直接进行操作
    const char* s_src = (const char*)src;//注意不要丢掉const,虽然不会影响结果，但却是不好的编程习惯
    while(count--){
        *tmp++ = *s_src++;
    }
    return dst;
}

void* my_memmove(void* dst, const void* src, size_t count){
    char* s_dst = dst;
    const char* s_src = (const char*)src;
    if(s_src<s_dst && (s_src + count > s_dst)){//处理第二种重叠情况，反向复制，从而变成第一种重叠情况
        s_dst = s_dst + n - 1;//移动到最后一个位置
        s_src = s_src + n - 1;//移动到最后一个位置
        while(count--){
            *s_dst-- = *s_src--;
        }
        else{
            while(n--){
                *s_dst++ = *s_src++;
            }
        }
        return dst;
    }
}
```
## 02 static关键字作用
可以用来修饰局部变量、全局变量。

修饰局部变量：改变变量生存周期。静态局部变量存在静态区，生命周期为整个程序运行期间

修饰全局变量：改变变量作用域。静态全局变量的作用域仅在当前文件有效，非静态全局变量整个工程都有效

修饰类成员函数：成为静态成员函数。只能访问静态成员变量。

## 03 多态（高频问题）
基类的指针或者引用指向派生类的对象，在调用虚函数时，会根据所指向对象实际的类型决定调用具体的某个虚函数。

优点：提升程序的可扩展性。增加派生类时，只需要按照派生类的特性，重载相应的虚函数，不用修改原始的代码。

实现原理：具有虚函数的类，都会维护一个虚函数表vtable和虚函数指针vptr指向该类的虚函数表，虚函数指针在类的构造函数初始化，指向对应的虚函数表，函数调用时，通过基类指针或者引用找到虚函数指针，根据指针找到对应的虚函数表，然后根据虚函数的声明顺序，确定偏移量，找到对应的虚函数地址。

注意：当要使用多态性质的时候，基类的析构函数需要被定义为虚函数，若基类的析构函数不是虚函数，那么在使用基类的指针或者引用指向派生类时，只会调用基类的析构函数，而不会调用派生类的构造函数，可能导致派生类的资源无法释放导致内存泄漏。

**什么时候会用到多态，解决什么问题**

封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在代码块，都是为了实现代码重用。
代码重用：将一个功能写成一个模块，以便需要相同功能的时候可以直接使用。

多态有两个好处：

1. 不必为每个派生类编写功能调试，只需要对抽象基类进行处理即可。提高程序的可复用性。
2. 派生类的功能可以被基类的指针或引用所调用，提高可扩充性和可维护性。 

- bool char short等非标准整数在运算前都必须转换为int
## 03 为什么内联函数，构造函数，静态成员函数不能为虚函数
内联函数：内联函数在编译期展开，而虚函数在运行时绑定，两者矛盾

构造函数：虚函数运行在对象建立基础之上，构造函数调用之前对象还未形成（虚函数指针还未初始化）

静态成员函数：静态成员函数属于一个类而非某个对象，无法根据对象进行判定调用哪个函数。（静态成员函数无需生成对象，直接调用）

## 04 如何消除隐式转换
使用explicit关键字修饰转移构造函数，防止不必要的隐式转换

## 05 volatile关键字作用
防止编译器进行优化，每次都让程序从内存中去读取数据

## 06 引用和指针的区别
指针是一个变量类型，可以不初始化，初始化后可以改变

引用是一个别名，引用必须初始化，且初始化后不可改变

## 07 异常处理
### 抛出异常
当执行一个throw时，跟在throw后面的语句不再执行。
- 沿着调用链的函数可能会提早退出
- 一旦程序开始执行异常处理代码，则沿着调用链创建的对象都将被销毁

### 栈展开
递归地尝试匹配catch子句。在栈展开过程中，退出了某个块，则将在这个块中构建的局部变量进行销毁

### 析构函数与异常
一般来说，析构函数不能抛出自身无法处理的异常，因为异常函数必须正确执行完毕。

### 重新抛出
有时，一个单独的catch语句无法处理某个异常。在执行某些校正操作之后，当前catch将重新抛出传递给另一个catch语句。

### 捕获所有异常的处理代码
```c++
catch(...){

}
```

## 08 常对象的成员变量是否能够修改
可以修改mutable修饰的成员变量

## 09 虚函数调用过程
找到对象内存中vptr所指向虚函数表的地址->找到虚函数表对应的虚函数地址。（实际可能是一个jmp指令，为了保护数据，不将地址暴露） 

## 10 C++四种类型转换方法
### 一、static_cast
替代c中的类型转换
### 二、dynamic_cast
dynamic_cast使用形式：
```c++
dynamic_cast<type*>(e);
dynamic_cast<type&>(e);
dynamic_cast<type&&>(e);
```
type必须是一个类类型，并且通常情况下应该含有虚函数。e的类型必须符合三个条件中的任意一个：
- e的类型是目标type的公有派生类
- e的类型是目标type的公有基类
- e的类型是目标type的类型

### 指针类型的dynamic_cast
```c++
if(Derived* dp = dynamic_cast<Derived*> (bp)){//bp为一个基类指针
    //bp指向Derived对象，转型安全
}
else{
    //bp指向Base对象，转型失败
}
//可以对一个空指针执行dynamic_cast，结果为所需要类型的空指针
```

### 引用类型的dynamic_cast
引用类型的dynamic_cast与指针类型的dynamic_cast表示错误发生的方式不同，因为不存在空引用，所以抛出std::bad_cast异常
```c++
void f(const Base &b){
    try{
        const Derived &d = dynamic_cast<const Derived&>(b);
        //使用b引用的Derived对象
    }
    catch(bad_cast){
        //处理类型转换失败的情况
    }
    

}
```

### 三、const_cast
const_cast只能改变运算对象底层const
```c++
const char* pc;
char* p = const_cast<char*> pc;//正确，但通过p进行写值是未定义行为
```

### 四、reinterpret_cast
为运算对象的位模式提供较低层次上的重新解释，但使用该转型比较危险，慎用。
```c++
int *ip;
char* pc = reinterpret_cast<char*> ip;
```

## 11 运算符重载
不能重载的运算符有. .* ?: :: 和sizeof

友元函数和成员函数使用场合：一般情况下，建议一元运算符使用成员函数，二元运算符使用友元函数
1. 运算符的操作需要修改类对象的状态，则使用成员函数。如需要做左值操作数的运算符（=，+=，++）
2. 运算时，有数和对象的混合运算时，必须使用友元
3. 二元运算符，第一个操作数为非对象时，必须使用友元函数。如输入输出运算符

运算符 | 建议使用
------ | -------
所有一元运算符 | 成员函数
= () [] -> | 必须成员函数
+= -= /= *= ^= != %= >>= <<= | 成员函数
所有二元运算符 | 友元函数
<< >> | 必须友元函数

## 12 a++与++a的区别
a++函数返回临时变量
++a函数返回*this

## 13 #ifndef,#define,#endif作用
保证即使头文件被多次包含，也只定义一次，用来防止头文件被重复包含，避免重定义错误，提高编译效率。
