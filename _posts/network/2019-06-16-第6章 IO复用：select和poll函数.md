# I/O复用：select和poll函数
## 概述
IO复用的典型应用场合：
- 处理多个描述符
- 处理多个套接字
- 同时处理TCP和UDP
- 处理多个服务或者协议

## I/O模型
五种IO模型：
1. 阻塞式IO
2. 非阻塞式IO
3. IO复用(select和poll)
4. 信号驱动式IO(SIGIO)
5. 异步IO(POSIX的aio_系列函数，前四种均为同步IO)

参考[知乎回答](https://www.zhihu.com/people/levonfly/activities)

**阻塞IO**：给女神发一条短信, 说我来找你了, 然后就默默的一直等着女神下楼, 这个期间除了等待你不会做其他事情, 属于备胎做法.

**非阻塞IO**： 给女神发短信, 如果不回, 接着再发, 一直发到女神下楼, 这个期间你除了发短信等待不会做其他事情, 属于专一做法.

**IO多路复用**：  是找一个宿管大妈来帮你监视下楼的女生, 这个期间你可以些其他的事情. 例如可以顺便看看其他妹子,玩玩王者荣耀, 上个厕所等等. 

IO复用又包括 select, poll, epoll 模式. 那么它们的区别是什么?
1. select大妈:每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子
2. poll大妈:不限制盯着女生的数量,  只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神
3. epoll大妈:不限制盯着女生的数量, 并且也不需要一个一个去问.  那么如何做呢?  epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字,  只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你.

上面这些**同步IO**有一个共同点就是, 当女神走出宿舍门口的时候, 你已经站在宿舍门口等着女神的, 此时你属于阻塞状态


接下来是**异步IO**的情况
你告诉女神我来了, 然后你就去王者荣耀了, 一直到女神下楼了, 发现找不见你了, 女神再给你打电话通知你, 说我下楼了, 你在哪呢?  这时候你才来到宿舍门口. 此时属于逆袭做法

## select函数
```c
#include <sys/select.h>
#include <sys/time.h>
/*
maxfdp1:指定待测试的描述符个数
三个fd_set指针：指定让内核测试读、写和异常条件的描述符，大多实现采用整数的位来表示描述符
timeout:告知内核等待所指定描述符中的任何一个就绪可花多少时间。三种可能：1.永远等待（nullptr）；2.等待一段时间；3.不等待：立即返回，轮询
返回：若有就绪描述符则返回其数目，若超时则为0，若出错则为-1
*/
int select(int maxfdp1, fd_set* readset, fd_set* writeset, fd_set* exceptset, const struct timeval* timeout);
```
### 描述符就绪条件
满足以下四个条件中任意一个时，套接字准备好读：
1. 套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小
2. 该连接的读半部关闭(接收了FIN的TCP连接)
3. 该套接字是一个监听套接字且完成的连接数不为0
4. 其上有一个套接字错误待处理

满足以下四个条件中任意一个时，套接字准备好写：
1. 该套接字的发送缓冲区的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小，并且或者该套接字已经连接，或者该套接字不需要连接
2. 该连接的写半部关闭(发送了FIN的TCP连接)
3. 使用非阻塞式的connect的套接字已经建立连接，或者connect已经以失败告终
4. 其上有个套接字错误待处理

## shutdown函数
close函数两个限制：
1. close将描述符引用计数减一，只有当计数变为0时才关闭套接字。shutdown直接激发TCP正常连接终止序列
2. close终止读写两个方向的数据传输。shutdown可以只关闭读或者写

```c
#include <sys/socket.h>
//howto:
//SHUT_RD:关闭读
//SHUT_WR:关闭写
//SHUT_RDWR:关闭读写
int shutdown(int sockfd, int howto);//成功返回0，出错返回-1
```

### 拒绝服务攻击
采用IO复用方式的服务器可能被拒绝服务攻击，若一个恶意客户端发出一个单字节数据（不是换行符），那么read调用则阻塞在这里等待该客户端发送换行符或者终止，此时，其他客户端的请求被挂起。

**拒绝服务攻击**基本概念：当一个服务器在处理多个客户时，它绝对不能阻塞于只与单个客户相关的某个函数调用。否则会导致服务器被挂起，拒绝为所有其他客户提供服务。

## poll函数
```c
#include <poll.h>
//nfds:指定结构数组中元素的个数
//timeout:poll函数前等待多长时间（-1 0 >0 三种）
//若有就绪描述符则返回其数目，超时为0，出错返回-1
int poll(struct pollfd *fdarray, unsigned long nfds, int timeout);

//用于指定测试某个给定描述符fd的条件
struct pollfd{
    int fd;
    short events;//测试条件
    short revents;//返回描述符状态
};
```




