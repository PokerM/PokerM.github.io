<h2>基本位操作</h2>

<p>位操作  |  描述 | 作用
-------| ------- |-------------
&amp; | 按位与 | 将特定位置0，或配合移位操作取出特定位元素
&amp;#124;  | 按为或  | 将特定位置1
^ | 异或 | 特定位取反，不引入第三变量，交换两个整数的值
~ | 取反 | 所有位取反</p>

<blockquote><blockquote><p>| 右移 | 右移一位相当于除以2
&lt;&lt; | 左移 | 左移一位相当于乘以2</p></blockquote></blockquote>

<h2>应用举例</h2>

<p>(1)判定整型奇偶
<code> c++
a &amp; 1 == 0
</code>
(2)取第K位
<code> c++
a &gt;&gt; k &amp; 1
</code>
(3)循环左移K次
<code> c++
a = a &lt;&lt; k | a &gt;&gt; sizeof(int) - k
</code>
(3)循环右移K次
<code> c++
a = a &gt;&gt; k | a &lt;&lt; sizeof(int) - k
</code>
(4)取两个整数的平均数
<code> c++
int mid = x &amp; y + (x ^ y) &gt;&gt; 1;
</code>
优点：不会出现(x + y)溢出的情况</p>

<p>(5)判断大于0的数是否为2的幂
<code> c++
(x != 0)&amp;&amp;(x &amp; (x-1) == 0)
</code>
(6)绝对值
<code> c++
int y = x &gt;&gt; (sizeof(int) - 1);
x = x ^ y - y;
</code>
(7)用位操作实现加法
<code>c++
int Add(int num1, int num2)
{
    while (num2!=0) {
        int temp = num1^num2;//取其不同部分
        num2 = (num1&amp;num2)&lt;&lt;1;//相同部分乘以2
        num1 = temp;
    }
    return num1;
}
</code>
(8)找出数组中唯一一个只出现一次的数字,其他数字出现两次
<code>c++
int singleNumber(vector&lt;int&gt;&amp; nums) {
        int res = 0;
        vector&lt;int&gt;::iterator it = nums.begin();
        for(;it != nums.end(); it++){
            res ^= (*it);
        }
        return res;
    }
</code>
升级版（其他数字出现三次）
<code>c++
int singleNumber(vector&lt;int&gt;&amp; nums) {
    int ones = 0, twos = 0;
    vector&lt;int&gt;::iterator it = nums.begin();
    for(;it != nums.end(); it++){
        ones = (ones ^ (*it)) &amp; ~twos;//找到只出现一次的位
        twos = (twos ^ (*it)) &amp; ~ones;//记录出现两次的位
    }
    return ones;
}
</code>
终极版（存在两个数字只出现一次）
<code>c++
    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums)
    {
        // Pass 1 :
        // Get the XOR of the two numbers we need to find
        int diff = accumulate(nums.begin(), nums.end(), 0, bit_xor&lt;int&gt;());
        // Get its last set bit，取出最后一个为1的位，由于两个数字不一样，必然存在其中一位不同，那么只需要找出其中一位，然后按情况区分
        diff &amp;= -diff;
        cout&lt;&lt;&quot;diff &quot;&lt;&lt;diff&lt;&lt;endl;
        // Pass 2 :
        vector&lt;int&gt; rets = {0, 0}; // this vector stores the two numbers we will return
        for (int num : nums)
        {
            if ((num &amp; diff) == 0) // the bit is not set
            {
                rets[0] ^= num;
            }
            else // the bit is set
            {
                rets[1] ^= num;
            }
            cout&lt;&lt;&quot;ret_0 = &quot;&lt;&lt;rets[0]&lt;&lt;&quot; ret_1 = &quot;&lt;&lt;rets[1]&lt;&lt;endl;
        }
        return rets;
    }
</code>
(9)重复的基因片段
基因字符串中重复出现的长度为10的子字符串<a href="https://leetcode.com/problems/repeated-dna-sequences/discuss/53952/20-ms-solution-(C%2B%2B)-with-explanation">LeetCode 187</a>
<code></code>`c++
    vector&lt;string&gt; findRepeatedDnaSequences(string s) {
        if (s.size() &lt;= 10)
            return vector&lt;string&gt;();</p>

<pre><code>    vector&lt;string&gt; R;
    bitset&lt;1&lt;&lt;20&gt; S1;//总共有4的10次方也就是2的20次方种可能
    bitset&lt;1&lt;&lt;20&gt; S2;

    int val = 0;
    for (int i=0; i &lt; 10; i++)   // Calc. the hash value for the first string.
        val = (val &lt;&lt; 2) | char2val(s[i]);
    S1.set(val);
    cout &lt;&lt; val &lt;&lt; &quot; | &quot;;

    int mask = (1 &lt;&lt; 20) - 1;//前20位
    for (int i=10; i &lt; s.size(); i++) {
        // Calc the hash value for the string ending at position i.
        val = ((val &lt;&lt; 2) &amp; mask) | char2val(s[i]);
        if (S2[val])
            continue;
        if (S1[val]) {
            R.push_back(s.substr(i-10+1, 10));
            S2.set(val);
        }
        else
            S1.set(val);
    }
    return R;
}

int char2val(char c) {
    switch (c) {
        case &#39;A&#39;: return 0;
        case &#39;C&#39;: return 1;
        case &#39;G&#39;: return 2;
        case &#39;T&#39;: return 3;
    }
    return 0;
 }</code></pre>

<p><code>
(10)字符长度最大乘积
思路：将字符编码，对应位置置1，然后通过&amp;判断是否存在相同。[Leetcode 318](https://leetcode.com/problems/maximum-product-of-word-lengths/discuss/225388/C%2B%2B-Beats-100-Simple-Bitwise-hashing-WITH-DETAILED-EXPLANATION)
</code>c++
int maxProduct(vector&lt;string&gt;&amp; words) {
    if(words.size()&lt;2) return 0;
    int maxProd = 0;</p>

<pre><code>int wordsLen = words.size();
vector&lt;int&gt; hash(wordsLen, 0);
//编码
for(int i = 0; i &lt; wordsLen; ++i){
    for(int j = 0; j &lt; words[i].length(); ++j){
        hash[i] = hash[i] | (1 &lt;&lt; (words[i][j]-&#39;a&#39;));
    }
}
//遍历判断是否存在字符
for(int i = wordsLen - 1; i &gt; 0; --i){
    for(int j = i - 1; j &gt;= 0; --j){
        if(!(hash[i] &amp; hash[j])){
            if(maxProd &lt; words[i].length() * words[j].length()){
                maxProd = words[i].length() * words[j].length();
            }
        }
    }
}
return maxProd;</code></pre>

<p>}
<code></code>`
(11)位计数</p>

<p>统计各个数字的二进制中1的个数
<code>c++
vector&lt;int&gt; countBits(int num) {
    vector&lt;int&gt; ret(num+1, 0);
    for (int i = 1; i &lt;= num; ++i)
        ret[i] = ret[i&amp;(i-1)] + 1;//i&amp;(i-1)得到2进制下只与i相差一位的数字
    return ret;
}
</code>
(12)total Hamming Distance
计算数组中每两个元素的Hamming距离，返回总距离<a href="https://leetcode.com/problems/total-hamming-distance/discuss/96250/C%2B%2B-O(n)-runtime-O(1)-space">Leetcode 477</a>
<code></code>`c++
int totalHammingDistance(vector&lt;int&gt;&amp; nums) {
    if (nums.size() &lt;= 0) return 0;</p>

<pre><code>int res = 0;
for(int i=0;i&lt;32;i++) {
    int setCount = 0;
    for(int j=0;j&lt;nums.size();j++) {
        if ( nums[j] &amp; (1 &lt;&lt; i) ) setCount++;//统计该位为1的数目
    }
    res += setCount * (nums.size() - setCount);//计算该位的Hamming总距离
}
return res;</code></pre>

<p>}
<code></code>`</p>
